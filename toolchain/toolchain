#!/bin/bash

apply_script ./os

#############################################################################################

function check_tools()
{
    if [[ -n $TOOLS ]]; then
        if [[ -d $TOOLS ]]; then
            set_result $(remove_end_slash $TOOLS)
        else
            throw "Invalid directory \$TOOLS ($TOOLS)"
        fi;
    fi;
}

function process_tools()
{
    local tools=$(check_tools)
    exit_on_error;
   
    define_echo_func get_tools_prefix tools

    declare _libs;
    declare _inc;
    if [[ -n $tools ]]; then
        _libs=$tools/lib
        _inc=$tools/include
    fi;

    define_echo_func 'get_tools_libs' _libs  # /lib64 /lib/x86_64...
    define_echo_func 'get_tools_include' _inc
    define_echo_func 'get_tools_prefix' tools

    #get_tools_prefix() {
    #    echo $tools
   # }
}

#####################   TOOLCHAIN & LIBC    ###############

function process_toolchain()
{
    if ! [[ -z $TOOLCHAIN || -d $TOOLCHAIN ]]; then
        # if set, and not a directory
        throw  "TOOLCHAIN($TOOLCHAIN) is not a directory"
    fi;
}

# $1 - libc prefix
function get_libc_path() {
    echo "$(os libc $1)/libc.so";
}

# $1 - libc.so path
function get_dynamic_loader() {
    echo $(ldd $1 | grep ld-linux | sed -e 's/[\t ]*//' | sed -e 's/[\t ]*(.*)[\t ]*$//')
}

# params:
#   $1 - path to libc
function gcc_param_dynamic_loader()
{
    echo "-Wl,--dynamic-linker=$(get_dynamic_loader $1)"
}

# get_libc_include_path()
# {
#    echo "$1/include"
# }

function extract_libc_path_from_loader_script()
{
    # ищем "GROUP (.*)".
    # -z заменяет \n на \0; делает вывод бинарным
    # -a бинарные файлы как текстовые.
    echo $(cat $1 | grep -zo "GROUP[ \t\n\r]*(.*)" | grep -ao "/[^ ]*libc.so[^ )]*")
}

# $1 libc.so path
function get_real_libc_path()
{
    local libc_path=$1
    local loader_script=$(readlink -e $libc_path)

    if [ ! $loader_script ]; then
        throw "Unable to locate libc library ($TARGET_BIT bit) at '$libc_path'"
    fi;

    if [ -f $loader_script ]; then
        if file $loader_script | grep ASCII > /dev/null; then
            result=$(extract_libc_path_from_loader_script $loader_script)
        elif file $loader_script | grep ELF > /dev/null; then
            result=$loader_script
        else
            throw "Undefined file type ($loader_script)"
        fi;
    else
        throw "Unable to locate libc library" 
    fi;

    set_result $result
}

function get_default_prefix()
{
    echo "/usr"
}

function check_libc_prefix()
{
    local default_prefix=$(get_default_prefix)
    local prefix=${LIBC_PREFIX:-${TOOLCHAIN:-$default_prefix}}
    
    if ! [[ -d $prefix ]]; then
        throw "LIBC_PREFIX($prefix) is not a directory"
    fi;

    declare result;
    
    if [[ "$default_prefix" = "$prefix" ]]; then
        result=$prefix      # suggest that system libc is in the right place. so do not check
    else
        if [[ -e $(get_libc_path $prefix) ]]; then
            result=$prefix
        fi;
    fi;

    if [[ -n $result ]]; then
        set_result $result
    else
        throw "Can't locate libc in $prefix"
    fi;

    define_echo_func $FUNCNAME result
}


function define_libc_related_func()
{
    prefix=$1
    if [[ $(get_default_prefix) == $prefix ]]; then
        define_bool_func 'is_system_libc' 0  # 0 = true
    else
        define_bool_func 'is_system_libc' 1  # 1 = false
    fi;
}

function process_libc()
{
    process_bit $TARGET_BIT

    declare libc_prefix;
    libc_prefix=$(check_libc_prefix);
    exit_on_error;

    define_libc_related_func $libc_prefix

    local libc=$(get_libc_path $libc_prefix) 

    declare real_libc;
    real_libc=$(get_real_libc_path $libc);
    exit_on_error;
    
    local flag_dynamic_loader=$(gcc_param_dynamic_loader $real_libc)
    local libc_dir=$(os libc $libc_prefix)
    local libc_include=$(os include $libc_prefix)

    define_echo_func '_get_libc_lib_dir' libc_dir
    define_echo_func '_get_libc_include_dir' libc_include
    define_echo_func '_get_dynamic_linker_flag' flag_dynamic_loader
}

function get_libc_prefix()
{
    if ! is_system_libc; then
        echo $(check_libc_prefix) 
    fi;
}

function get_libc_lib_dir()
{
    if ! is_system_libc; then
        echo $(_get_libc_lib_dir) 
    fi;

}

function get_libc_include_dir()
{
    if ! is_system_libc; then
        echo $(_get_libc_include_dir) 
    fi;

}

function get_dynamic_linker_flag()
{
    if ! is_system_libc; then
        echo $(_get_dynamic_linker_flag) 
    fi;
}

function get_bit_flags()
{
    if ! is_system_default_bit; then
        set_result "-m$(get_bit)"
    fi;
}

# $1 - path to gcc
# result - path to g++
function gcc_gplusplus()
{
    dir=$(dirname $1)
    gpp=$(basename $1 | sed 's/gcc/g++/')
    echo $dir/$gpp
}

# $1 - path to gcc
function gcc_libs_path()
{
    set_result "$($1 $(get_bit_flags) --print-file-name=libstdc++.so | xargs readlink -f | xargs dirname)"
}

function check_gcc(){
    local gcc=$GCC

    if [[ -n $gcc ]]; then
        if ! [[ -e $gcc ]]; then
           throw "Can't locate gcc in (\$GCC=$gcc)" 
        fi;

        set_result $gcc
    else
        local prefix=$TOOLCHAIN
        local gcc_path='/bin/gcc'
        local gcc_full_path=

        if [[ -n $prefix ]]; then
            gcc_full_path="${prefix}${gcc_path}"

            if ! [[ -e "$gcc_full_path" ]]; then
                throw "Can't locate gcc in (\$TOOLCHAIN=$prefix)"
            fi;
        else
            # не задан GCC и TOOLCHAIN
            # ищем системный
            gcc_full_path=$(which gcc);
        fi;

        set_result $gcc_full_path
    fi;
}

function getGCCVersionInt() {
    gcc_version=$($CXX -dumpversion | cut -d. -f-2)
    
    major=$(echo $gcc_version | sed 's/\..*//')
    minor=$(echo $gcc_version | sed "s/$major\.//" | cut -c-2)
    
    if [[ ${#minor} -gt 1 ]] ; then
        ver=${major}${minor}
    else
        ver=${major}0${minor}
    fi;

    set_result $ver;
}

function defineGCCRelevantFlags()
{
    GCC_VERSION=$(getGCCVersionInt)
    
    if [[ "$GCC_VERSION" -lt 403 ]] ; then
        USE_CPP_STD='c++98'
    fi;

    if [[ "$GCC_VERSION" -ge 403 && "$GCC_VERSION" -lt 407 ]] ; then
        USE_CPP_STD='c++0x'
    fi;

    if [[ "$GCC_VERSION" -ge 408 && "$GCC_VERSION" -lt 504 ]] ; then
        USE_CPP_STD='c++11'
    fi;

    if [[ "$GCC_VERSION" -ge 601 && "$GCC_VERSION" -le 700 ]] ; then
        USE_CPP_STD='c++14'
    fi;

    export readonly CPP_STD_VERSION=${CPP_STD_VERSION:-$USE_CPP_STD};

    if [[ "$CPP_STD_VERSION" = 'c++11' ]] || [[ "$CPP_STD_VERSION" = 'c++14' ]]  ; then
        WARNINGS="-Wno-unused-local-typedefs"
    fi

    export CFLAGS="$ASTRA_FLAGS $WARNINGS $CFLAGS"
    export CXXFLAGS="${CPP_STD_VERSION:+-std=$CPP_STD_VERSION} $ASTRA_FLAGS $WARNINGS $CXXFLAGS"
}

export -f getGCCVersionInt

# $1 - path to some directory
# result:
#   0 - if dir one of /usr/lib /usr/lib64 for Red Hat, or /usr/lib32 /usr/lib/x86_64-linux-gnu for Ubuntu
#   1 - else
function is_system_lib_dir() {
    [[ "/usr$(get_host_libdir)" = $1 ]];
}

# $1 - language (c or c++)
function get_compiler() {
    local lang=${1:-c}

    case $lang in
        "c")
            res=$(get_gcc)
        ;;
        "c++")
            res=$(get_gplusplus)
        ;;
        *)
            throw "Unsupported language - $1"
        ;;
    esac;

    set_result $res;
}

function process_gcc()
{
    declare result;
    result=$(check_gcc)
    exit_on_error;

    define_empty_func process_gcc
    define_echo_func 'get_gcc' result

    gpp=$(gcc_gplusplus $result)
    define_echo_func 'get_gplusplus' gpp

    local gcc_lib_dir=$(gcc_libs_path $result)

    if ! is_system_lib_dir $gcc_lib_dir ; then
        define_echo_func 'get_gcc_lib_dir' gcc_lib_dir
    else
        define_empty_func 'get_gcc_lib_dir'
    fi;
}

#############################   BINUTILS    ##############################

function check_binutils()
{
    local prefix=$BINUTILS_PREFIX
    
    if [[ -z $prefix ]]; then
        prefix=$TOOLCHAIN
    else
        if ! [[ -d $prefix && -e "$prefix/bin/ld" ]]; then
            throw "Can't locate binutils ($prefix)"
        fi;
    fi;

    set_result $prefix;
}

function process_binutils()
{
    declare prefix;
    prefix=$(check_binutils)
    exit_on_error;

    define_echo_func $FUNCNAME prefix
    define_echo_func 'get_binutils_prefix' prefix
}

########################################################################

process_toolchain
process_libc 
process_gcc
process_binutils
process_tools

